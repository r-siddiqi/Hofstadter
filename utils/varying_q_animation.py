# -*- coding: utf-8 -*-
"""varying_q_animation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b7VfcbFhgrjGt5cdYIwARGqKl9xEfYir
"""

# Animation for varying q values
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
plt.style.use('dark_background')

def animate_butterfly_q_evolution(length=20, t=1.0, min_q=10, max_q=100, num_frames=50, save_path=None):
  """
  Animate the evolution of the Hofstadter butterfly as q increases
  """
  fig, ax = plt.subplots(figsize=(12, 8))
  ax.set_xlabel('Flux per Plaquette Φ')
  ax.set_ylabel('Energy E')

  def update(frame):
    ax.clear()
    ax.set_xlabel('Flux per Plaquette Φ')
    ax.set_ylabel('Energy E')
    ax.grid(True, alpha=0.2)

    # Calculate q value for this frame
    q = int(min_q + (max_q - min_q) * (frame / (num_frames - 1)))

    # Create model and generate data
    model = Square_Hamiltonian(length=length, t=t, W=0.0, phi=0.0, q=q)
    phis = []
    energies = []

    for q_val in range(1, q + 1):
      for p in range(q_val + 1):
        if gcd(p, q_val) == 1:
          model.phi = p / q_val
          model.construct_hamiltonian()
          phis.extend([model.phi] * model.N)
          energies.extend(model.evals.tolist())

    ax.scatter(phis, energies, s=0.1, color='blue', alpha=0.5)
    ax.set_title(f'Hofstadter Butterfly (W=0.0, t={t:.1f}, q={q})')
    ax.set_xlim(-0.1, 1.1)
    ax.set_ylim(-4, 4)

    return ax

  anim = FuncAnimation(
      fig,
      update,
      frames=num_frames,
      interval=100
  )

  if save_path:
      print(f"Saving animation to {save_path}")
      anim.save(save_path, writer='pillow', fps=10)
  else:
      plt.show()

  plt.close()

# Generate animation for varying q
animate_butterfly_q_evolution(save_path='butterfly_q_evolution.gif')